global
    stats socket ipv4@127.0.0.1:{{haproxy_api_port + services[cluster][subcluster][service]['port_offset']}} level admin
    tune.ssl.default-dh-param 2048
    ssl-default-bind-ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256
    ssl-default-bind-options no-sslv3 no-tlsv10 no-tlsv11 no-tls-tickets
    maxconn 10000


defaults
    # log /dev/log local0 debug
    mode tcp
    timeout connect 3600s
    # Timeout set to 1 year to avoid reconnects
    # In case we have problems with too many open connections - decrease this value
    timeout server 2147483647ms
    timeout client 2147483647ms
    default-server inter 500 rise 1 fall 1 on-marked-down shutdown-sessions

# Check 3 sentinels to see if they think srv1 is master
backend srv1
    option tcp-check
    tcp-check connect
    tcp-check send AUTH\ {{secrets[cluster][subcluster][service]['password']}}\r\n
    tcp-check expect string +OK
    tcp-check send PING\r\n
    tcp-check expect string +PONG
    tcp-check send SENTINEL\ master\ default\r\n
    tcp-check expect string {{instances[cluster][subcluster]['srv1']}}
    tcp-check send QUIT\r\n
    tcp-check expect string +OK

    server redis1 {{instances[cluster][subcluster]['srv1']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv1']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}
    server redis2 {{instances[cluster][subcluster]['srv1']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv2']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}
    server redis3 {{instances[cluster][subcluster]['srv1']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv3']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}


# Check 3 sentinels to see if they think srv2 is master
backend srv2
    option tcp-check
    tcp-check connect
    tcp-check send AUTH\ {{secrets[cluster][subcluster][service]['password']}}\r\n
    tcp-check expect string +OK
    tcp-check send PING\r\n
    tcp-check expect string +PONG
    tcp-check send SENTINEL\ master\ default\r\n
    tcp-check expect string {{instances[cluster][subcluster]['srv2']}}
    tcp-check send QUIT\r\n
    tcp-check expect string +OK

    server redis1 {{instances[cluster][subcluster]['srv2']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv1']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}
    server redis2 {{instances[cluster][subcluster]['srv2']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv2']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}
    server redis3 {{instances[cluster][subcluster]['srv2']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv3']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}


# Check 3 sentinels to see if they think srv3 is master
backend srv3
    option tcp-check
    tcp-check connect
    tcp-check send AUTH\ {{secrets[cluster][subcluster][service]['password']}}\r\n
    tcp-check expect string +OK
    tcp-check send PING\r\n
    tcp-check expect string +PONG
    tcp-check send SENTINEL\ master\ default\r\n
    tcp-check expect string {{instances[cluster][subcluster]['srv3']}}
    tcp-check send QUIT\r\n
    tcp-check expect string +OK

    server redis1 {{instances[cluster][subcluster]['srv3']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv1']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}
    server redis2 {{instances[cluster][subcluster]['srv3']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv2']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}
    server redis3 {{instances[cluster][subcluster]['srv3']}}:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check addr {{instances[cluster][subcluster]['srv3']}} port {{sentinel_port + services[cluster][subcluster][service]['port_offset']}}


# Main Redis frontend, always directed to master, with SSL bind only to private subnet address (used by application)
frontend ft_redis_ssl # [port 6379 + offset]
    bind {{ansible_default_ipv4.address}}:{{haproxy_redis_ssl_port + services[cluster][subcluster][service]['port_offset']}} ssl crt /etc/quiq.corp.crt.and.key.pem
    acl ACL_redis_1_is_down nbsrv(srv1) lt 2
    acl ACL_redis_2_is_down nbsrv(srv2) lt 2
    acl ACL_redis_3_is_down nbsrv(srv3) lt 2
    use_backend srv2 if ACL_redis_1_is_down ACL_redis_3_is_down
    use_backend srv3 if ACL_redis_1_is_down ACL_redis_2_is_down
    use_backend srv1 if ACL_redis_2_is_down ACL_redis_3_is_down


# Redis frontend, always directed to master, withous SSL bind only to localhost (used by redis-commander)
frontend ft_redis_nonssl # [port 6379 + offset]
    bind 127.0.0.1:{{haproxy_redis_ssl_port + services[cluster][subcluster][service]['port_offset']}}
    acl ACL_redis_1_is_down nbsrv(srv1) lt 2
    acl ACL_redis_2_is_down nbsrv(srv2) lt 2
    acl ACL_redis_3_is_down nbsrv(srv3) lt 2
    use_backend srv2 if ACL_redis_1_is_down ACL_redis_3_is_down
    use_backend srv3 if ACL_redis_1_is_down ACL_redis_2_is_down
    use_backend srv1 if ACL_redis_2_is_down ACL_redis_3_is_down


# Sentinel over SSL (used by application)
backend bk_sentinel_local
    option tcp-check
    tcp-check connect
    server sentinel_local 127.0.0.1:{{sentinel_port + services[cluster][subcluster][service]['port_offset']}} check inter 5s

frontend ft_sentinel_ssl # [port 16379 + offset]
    bind *:{{haproxy_sentinel_ssl_port + services[cluster][subcluster][service]['port_offset']}} ssl crt /etc/quiq.corp.crt.and.key.pem
    use_backend bk_sentinel_local


# Backend connected to local Redis
backend bk_redis_local
    option tcp-check
    tcp-check connect
    server redis_local 127.0.0.1:{{redis_port + services[cluster][subcluster][service]['port_offset']}} check inter 5s


# Direct NON-SSL connection to local Redis (used by replica and sentinels)
frontend ft_redis_local # [port 46379 + offset]
    bind *:{{haproxy_redis_local_port + services[cluster][subcluster][service]['port_offset']}}
    use_backend bk_redis_local


# Direct connection to local Redis over SSL (used by status check scripts)
frontend ft_redis_local_ssl # [port 56379 + offset]
    bind *:{{haproxy_redis_local_ssl_port + services[cluster][subcluster][service]['port_offset']}} ssl crt /etc/quiq.corp.crt.and.key.pem
    use_backend bk_redis_local


# Haproxy API, unsecured port bind to localhost and SSL/TLS secured bind only to private subnet address
backend api_loopback
    server haproxy_api 127.0.0.1:{{haproxy_api_port + services[cluster][subcluster][service]['port_offset']}} check inter 5s

frontend api_loopback_ssl # [port 9899 + offset]
    bind {{ansible_default_ipv4.address}}:{{haproxy_api_port + services[cluster][subcluster][service]['port_offset']}} ssl crt /etc/quiq.corp.crt.and.key.pem verify required ca-file /etc/quiq.corp.crt.and.key.pem
    use_backend api_loopback
